
\section{Conclusions}
\label{chap:conclusions}

A codebase's real value lies not in the fact that it exists, but in that
it has been proven and hardened ``out there''.  The purpose of this work
is harnessing the power and stability of existing in-kernel drivers.

We defined an \textit{anykernel} to be an organization of kernel code
which allows the kernel's \textit{unmodified} drivers to be run in various
configurations such as libraries, servers, small standalone operating
systems, and also in the original monolithic kernel.  We showed by means
of a production quality implementation that the NetBSD monolithic kernel
could be turned into an anykernel with relatively simple modifications.
The key point is retaining the battle-hardened nature of the drivers.

An anykernel can be instantiated into units which include the minimum
support functionality for running kernel driver components.  These units
are called \textit{rump kernels} since they provide only a part of
the original kernel's features.  Features not provided by rump kernels
include for example a thread scheduler, virtual memory and the capability
to execute binaries.  These omissions make rump kernels straightforward
to integrate into any platform that has approximately one megabyte or
more of RAM and ROM.  Alternatively, entirely new software stacks built
around rump kernels are possible to execute with relative ease, as we
explored with the Rumprun unikernel.

As the parting thoughts, we remind ourselves of why operating systems
have the role they currently have, and what we should do to move
forward.

The birth of timesharing operating systems took place over 50 years ago,
an era from which we draw even the current concept of the operating system.
Back then, hardware was simple, scarce and sacred, and those attributes
drove the development of the concepts of the system and the users.
In the modern world, computing is done in a multitude of ways, and the
case for the all-encompassing operating system has watered down.

The most revered feature of the modern operating system is support for
running existing applications.  We can harness that power through rump
kernels.  Therefore, there is no reason to cram a traditional operating
system into every problem space.  Instead, we should choose
the most suitable software stack based on the problem at hand.
